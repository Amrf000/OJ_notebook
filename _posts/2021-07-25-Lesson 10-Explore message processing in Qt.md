---
layout: post
title: Lesson 10-Explore message processing in Qt
category: qt5
tags: [qt5]
---
# 

## 

##### 

### 

1\. Qt message model

Qt encapsulates the message mechanism of specific operating systems

Qt follows the classic GUI message-driven event model

![](/public/assets/2021-07-25/8315335e3e268047d72cf150ca1f5a7b.png)

2\. Thinking

In Qt ChinaHow to represent user messages? A

In Qt ChinaHow to map user messages to message processing functions? AIn Qt ChinaWhat are the rules for message mapping? A

3\. Signals and slots

Qt defines concepts related to system messages

－Signal

............ Messages generated by the operating system

-Slot

............ Message processing function in the program

------Connect

............ Bind system messages to message processing functions

Message processing mechanism in Qt

![](/public/assets/2021-07-25/ce1fae850a34599e7a3fbcf40a079236.png)

The connection of the signal to the slot must occur between two Qt class objects! A

The core of Qt-QObject::connectFunction

![](/public/assets/2021-07-25/f301aa33206c82f892f1fe8b37c4daf5.png)

- Note: 

In Qt, the message is used in QtStringDescribe

• The connect function is inMessage namewithHandler functionbetweenEstablish mapping

"New" keywords in Qt

- SIGNAL (Macro)

. Used to specifyMessage name

- SLOT 

. ForSpecify the message processing function name

- Q\_OBJECT . All custom slot classesQ\_OBJECT must be added at the beginning of the class declaration  
  

- slots . Used in classDeclare the message processing function  

4\. Programming experiment

Probe into signals and slots 10-1.pro
    

1. #include <QtGui/QApplication>
    

2. #include <QPushButton>
    

3. 4. int main(int argc, char *argv[])
    

5. {
    

6.  QApplication a(argc, argv);
    

7.  QPushButton b;//Become the top-level window
    

8. 9.  b.setText("Click me to quit!");
    

10. 11.  b.show();
    

12. 13.  QObject::connect(&b,SIGNAL(clicked()),&a,SLOT(quit()));
    

14. 15.  //Map the click message of the button object to the quit function of the a object
    

16. 17. 18.  return a.exec();
    

19. }
    
    

![](/public/assets/2021-07-25/18ecc2a12547c80c60dd350cac4ee985.png)

5\. Custom slot

OnlyQObjectSub-categoryCustom slot

The class that defines the slot must be inUse Q\_OBJECT at the beginning of the declaration

In the categoryDeclaration slotNeed to useslotsKeywords

The function signature of the slot and the processed signal must be consistent

Among the names specified by SIGNAL and SLOT:

－Can contain parameter types•-Cannot contain specific parameter names

6\. Programming experimentAdd a message processing function for the calculator instance

QCalculatorUI.h
    

1. #ifndef _QCALCULATORUI_H_
    

2. #define _QCALCULATORUI_H_
    

3. 4. #include <QWidget>
    

5. #include <QLineEdit>
    

6. #include <QPushButton>
    

7. 8. class QCalculatorUI : public QWidget
    

9. {
    

10.  Q_OBJECT
    

11. private:
    

12.  QLineEdit* m_edit;
    

13.  QPushButton* m_buttons[20];
    

14. 15.  QCalculatorUI();
    

16.  bool construct();
    

17. private slots:
    

18.  void onButtonClicked();
    

19. public:
    

20.  static QCalculatorUI* NewInstance();
    

21.  void show();
    

22.  ~QCalculatorUI();
    

23. };
    

24. 25. #endif
    
    

QCalculatorUI.cpp
    

1. #include "QCalculatorUI.h"
    

2. #include <QDebug>
    

3. 4. QCalculatorUI::QCalculatorUI() : QWidget(NULL, Qt::WindowCloseButtonHint)
    

5. {
    

6. 7. }
    

8. 9. bool QCalculatorUI::construct()
    

10. {
    

11.  bool ret = true;
    

12.  const char* btnText[20] =
    

13.  {
    

14.  "7", "8", "9", "+", "(",
    

15.  "4", "5", "6", "-", ")",
    

16.  "1", "2", "3", "*", "<-",
    

17.  "0", ".", "=", "/", "C",
    

18.  };
    

19. 20.  m_edit = new QLineEdit(this);
    

21. 22.  if( m_edit != NULL )
    

23.  {
    

24.  m_edit->move(10, 10);
    

25.  m_edit->resize(240, 30);
    

26.  m_edit->setReadOnly(true);
    

27.  }
    

28.  else
    

29.  {
    

30.  ret = false;
    

31.  }
    

32. 33.  for(int i=0; (i<4) && ret; i++)
    

34.  {
    

35.  for(int j=0; (j<5) && ret; j++)
    

36.  {
    

37.  m_buttons[i*5 + j] = new QPushButton(this);
    

38. 39.  if( m_buttons[i*5 + j] != NULL )
    

40.  {
    

41.  m_buttons[i*5 + j]->resize(40, 40);
    

42.  m_buttons[i*5 + j]->move(10 + (10 + 40)*j, 50 + (10 + 40)*i);
    

43.  m_buttons[i*5 + j]->setText(btnText[i*5 + j]);
    

44. 45.  connect(m_buttons[i*5 + j], SIGNAL(clicked()), this, SLOT(onButtonClicked()));
    

46.  }
    

47.  else
    

48.  {
    

49.  ret = false;
    

50.  }
    

51.  }
    

52.  }
    

53. 54.  return ret;
    

55. }
    

56. 57. QCalculatorUI* QCalculatorUI::NewInstance()
    

58. {
    

59.  QCalculatorUI* ret = new QCalculatorUI();
    

60. 61.  if( (ret == NULL) || !ret->construct() )
    

62.  {
    

63.  delete ret;
    

64.  ret = NULL;
    

65.  }
    

66. 67.  return ret;
    

68. }
    

69. 70. void QCalculatorUI::show()
    

71. {
    

72.  QWidget::show();
    

73. 74.  setFixedSize(width(), height());
    

75. }
    

76. 77. void QCalculatorUI::onButtonClicked()
    

78. {
    

79.  QPushButton* btn = (QPushButton*)sender(); //Returns the connection that sent the signal returns the clicked button pointer
    

80. 81.  qDebug() << "onButtonClicked()";	
    

82.  qDebug() << btn->text();
    

83. }
    

84. 85. QCalculatorUI::~QCalculatorUI()
    

86. {
    

87. 88. }
    
    

main.cpp
    

1. #include <QtGui/QApplication>
    

2. #include "QCalculatorUI.h"
    

3. 4. int main(int argc, char *argv[])
    

5. {
    

6.  QApplication a(argc, argv);
    

7.  QCalculatorUI* cal = QCalculatorUI::NewInstance();
    

8.  int ret = -1;
    

9. 10.  if( cal != NULL )
    

11.  {
    

12.  cal->show();
    

13. 14.  ret = a.exec();
    

15. 16.  delete cal;
    

17.  }
    

18. 19.  return ret;
    

20. }
    
    

![](/public/assets/2021-07-25/41ea845ef0dea010be13f3206fd71350.png)  

7\. Tips

Solve classic problems:Object::connect: No such slot... 、

1\. Check if the class inherits from QObject

2\. Check whether Q\_OB ECT is added at the beginning of the class declaration

3\. Check whether the slot keyword is used for slot declaration,

4\. Check if the name of the slot is misspelled

5\. Re-execute qmake

For more details, see the following text for more details

8\. Summary

Signals and slots are the core mechanism in Qt

Different Qt objects can communicate through signals and slots

Only subclasses of QObject can customize signals and slots

Classes that use signals and slots must use Q\_OBJECT at the beginning of the declaration

The signal and the processing function must be consistent on the function signature