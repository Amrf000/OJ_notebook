---
layout: post
title: qt-master
category: Tools
tags: [markdown]
---

[qt-master]({{ site.baseurl }}/hblogs/2021-07-18-qt-master.html)
* Using a QDialog

```
bool ok;
QString name = QInputDialog::getText(this,
    tr("Add task"),
    tr("Task name"),
    QLineEdit::Normal,
    tr("Untitled task"), &ok);
if (ok && !name.isEmpty()) {
    qDebug() << "Adding new task";
    Task* task = new Task(name);
    mTasks.append(task);
    ui->tasksLayout->addWidget(task);
}
```

* Emitting a custom signal using lambdas

```
connect(ui->removeButton, &QPushButton::clicked, [this] {
    emit removed(this);
});

connect(ui->removeButton, &QPushButton::clicked, [this, name] {
    qDebug() << "Trying to remove" << name;
    this->emit removed(this);
});
```

* singleton 

```
class SysInfo
{
public:
    static SysInfo& instance();
    virtual ~SysInfo();
    virtual void init() = 0;
    virtual double cpuLoadAverage() = 0;
    virtual double memoryUsed() = 0;
protected:
    explicit SysInfo();
private:
    SysInfo(const SysInfo& rhs);// or c++11 = delete
    SysInfo& operator=(const SysInfo& rhs);
};

#ifdef Q_OS_WIN
#include "SysInfoWindowsImpl.h"
#elif defined(Q_OS_MAC)
#include "SysInfoMacImpl.h"
#elif defined(Q_OS_LINUX)
#include "SysInfoLinuxImpl.h"
#endif
SysInfo& SysInfo::instance()
{
#ifdef Q_OS_WIN
    static SysInfoWindowsImpl singleton;
#elif defined(Q_OS_MAC)
    static SysInfoMacImpl singleton;
#elif defined(Q_OS_LINUX)
    static SysInfoLinuxImpl singleton;
#endif
return singleton;
}
```

* QChart

```
#include <QtCharts/QChartView>
QtCharts::QChartView mChartView;

mRefreshTimer.setInterval(updateSeriesDelayMs);
connect(&mRefreshTimer, &QTimer::timeout,
this, &SysInfoWidget::updateSeries);
QTimer::singleShot(startDelayMs,
[this] { mRefreshTimer.start(); });
mChartView.setRenderHint(QPainter::Antialiasing);
mChartView.chart()->legend()->setVisible(false);

#include <QtCharts/QpieSeries>// 饼图
protected slots:
    void updateSeries() override;
QtCharts::QPieSeries* mSeries;

mSeries->setHoleSize(0.35);
mSeries->append("CPU Load", 30.0);
mSeries->append("CPU Free", 70.0);
QChart* chart = chartView().chart();
chart->addSeries(mSeries);
chart->setTitle("CPU average load");

void CpuWidget::updateSeries()
{
    double cpuLoadAverage = SysInfo::instance().cpuLoadAverage();
    mSeries->clear();
    mSeries->append("Load", cpuLoadAverage);
    mSeries->append("Free", 100.0 - cpuLoadAverage);
}

QtCharts::QLineSeries* mSeries;
#include <QtCharts/QAreaSeries> //折线图
QAreaSeries* areaSeries = new QAreaSeries(mSeries);
QChart* chart = chartView().chart();
chart->addSeries(areaSeries);
chart->setTitle("Memory used");
chart->createDefaultAxes();
chart->axisX()->setVisible(false);
chart->axisX()->setRange(0, CHART_X_RANGE_MAX);
chart->axisY()->setRange(0, 100);

void MemoryWidget::updateSeries()
{
    double memoryUsed = SysInfo::instance().memoryUsed();
    mSeries->append(mPointPositionX++, memoryUsed);
    if (mSeries->count() > CHART_X_RANGE_COUNT) {
        QChart* chart = chartView().chart();
            chart->scroll(chart->plotArea().width()
            / CHART_X_RANGE_MAX, 0);
        mSeries->remove(0);
    }
}
```

* condition compile

```
windows|unix {
SOURCES += SysInfoWindowsAndLinux.cpp
} else:macx {
SOURCES += SysInfoMacImpl.cpp
} else {
SOURCES += UltimateGenericSources.cpp
}

windows {
SOURCES += SysInfoWindowsImpl.cpp
HEADERS += SysInfoWindowsImpl.h
message($$COMPILE_MSG windows)
}
linux {
SOURCES += SysInfoLinuxImpl.cpp
HEADERS += SysInfoLinuxImpl.h
message($$COMPILE_MSG linux)
}
macx {
SOURCES += SysInfoMacImpl.cpp
HEADERS += SysInfoMacImpl.h
message($$COMPILE_MSG mac)
}

windows:message($$COMPILE_MSG windows)
```

* qmake

```
/path/to/qt/installation/5.7/gcc_64/bin/qmake -makefile -o Makefile
/path/to/sysinfoproject/ch02-sysinfo.pro

make

make->moc -> g++
    ->uic
    ->qrc
```

* Beneath Q_OBJECT and signals/slots

```
#define Q_OBJECT \
public: \
// skipped details
static const QMetaObject staticMetaObject; \
virtual const QMetaObject *metaObject() const; \
virtual void *qt_metacast(const char *); \
virtual int qt_metacall(QMetaObject::Call, int, void **); \
QT_TR_FUNCTIONS \
private: \
// skipped details
qt_static_metacall(QObject *, QMetaObject::Call, int, void **);

# define slots
# define signals public

# define emit

struct Connection
{
    QObject *sender;
    QObject *receiver;
    union {
        StaticMetaCallFunction callFunction;
        QtPrivate::QSlotObjectBase *slotObj;
    };
    // The next pointer for the singly-linked ConnectionList
    Connection *nextConnectionList;
    //senders linked list
    Connection *next;
    Connection **prev;
    ...
};
```

* Application/library project separation

```
TEMPLATE = subdirs
SUBDIRS += \
gallery-core

QT += sql
QT -= gui
TARGET = gallery-core
TEMPLATE = lib
DEFINES += GALLERYCORE_LIBRARY
SOURCES += Album.cpp
HEADERS += Album.h\
            gallery-core_global.h
unix {
    target.path = /usr/lib
    INSTALLS += target
}

#include <QtCore/qglobal.h>
#if defined(GALLERYCORE_LIBRARY)
# define GALLERYCORESHARED_EXPORT Q_DECL_EXPORT
#else
# define GALLERYCORESHARED_EXPORT Q_DECL_IMPORT
#endif

```

* Database interaction with Qt

```
#include <QString>
class QSqlDatabase;
const QString DATABASE_FILENAME = "gallery.db";
class DatabaseManager
{
public:
    static DatabaseManager& instance();
    ~DatabaseManager();
protected:
    DatabaseManager(const QString& path = DATABASE_FILENAME);
    DatabaseManager& operator=(const DatabaseManager& rhs);
private:
    QSqlDatabase* mDatabase;
};

#include "DatabaseManager.h"
#include <QSqlDatabase>
DatabaseManager& DatabaseManager::instance()
{
    static DatabaseManager singleton;
    return singleton;
}
DatabaseManager::DatabaseManager(const QString& path) :
    mDatabase(new QSqlDatabase(QSqlDatabase::addDatabase("QSQLITE")))
{
    mDatabase->setDatabaseName(path);
    mDatabase->open();
}
DatabaseManager::~DatabaseManager()
{
    mDatabase->close();
    delete mDatabase;
}

class QSqlDatabase;
class AlbumDao
{
public:
    AlbumDao(QSqlDatabase& database);
    void init() const;
private:
    QSqlDatabase& mDatabase;
};

#include <QSqlDatabase>
#include <QSqlQuery>
#include "DatabaseManager.h"
AlbumDao::AlbumDao(QSqlDatabase& database) :
mDatabase(database)
{
}
void AlbumDao::init() const
{
    if (!mDatabase.tables().contains("albums")) {
        QSqlQuery query(mDatabase);
        query.exec("CREATE TABLE albums (id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT)");
    }
}

// In DatabaseManager.h
#include "AlbumDao.h"
...
private:
    QSqlDatabase* mDatabase;
public:
    const AlbumDao albumDao;
};
    // In DatabaseManager.cpp
    DatabaseManager::DatabaseManager(const QString& path) :
    mDatabase(new QSqlDatabase(QSqlDatabase::addDatabase("QSQLITE"))),
albumDao(*mDatabase)
{
    mDatabase->setDatabaseName(path);
    mDatabase->open();
    albumDao.init();
}

// In AlbumDao.h
class QSqlDatabase;
class Album;
class AlbumDao
{
public:
    AlbumDao(QSqlDatabase& database);
    void init() const;
    void addAlbum(Album& album) const;
    ...
};
// In AlbumDao.cpp
#include <QSqlDatabase>
#include <QSqlQuery>
#include <QVariant>
...
void AlbumDao::addAlbum(Album& album) const
{
    QSqlQuery query(mDatabase);
    query.prepare("INSERT INTO albums (name) VALUES (:name)");
    query.bindValue(":name", album.name());
    query.exec();
    album.setId(query.lastInsertId().toInt());
}

// In AlbumDao.h
#include <QVector>
...
void addAlbum(Album& album) const;
void updateAlbum(const Album& album) const;
void removeAlbum(int id) const;
QVector<Album*> albums() const;
...
};
// In AlbumDao.cpp
QVector<Album*> AlbumDao::albums() const
{
    QSqlQuery query("SELECT * FROM albums", mDatabase);
    query.exec();
    QVector<Album*> list;
    while(query.next()) {
        Album* album = new Album();
        album->setId(query.value("id").toInt());
        album->setName(query.value("name").toString());
        list.append(album);
    }
    return list;
}

// In PictureDao.h
#include <QVector>
class QSqlDatabase;
class Picture;
class PictureDao
{
public:
    explicit PictureDao(QSqlDatabase& database);
    void init() const;
    void addPictureInAlbum(int albumId, Picture& picture) const;
    void removePicture(int id) const;
    void removePicturesForAlbum(int albumId) const;
    QVector<Picture*> picturesForAlbum(int albumId) const;
private:
    QSqlDatabase& mDatabase;
};
// In PictureDao.cpp
void PictureDao::init() const
{
    if (!mDatabase.tables().contains("pictures")) {
        QSqlQuery query(mDatabase);
        query.exec(QString("CREATE TABLE pictures")
        + " (id INTEGER PRIMARY KEY AUTOINCREMENT, "
        + "album_id INTEGER, "
        + "url TEXT)");
    }
}
```

* Smart pointers with C++14

```
The unique_ptr pointer indicates that the owner is the only owner of the pointer
The shared_ptr pointer indicates that the pointer's ownership is shared among several
clients
The weak_ptr pointer indicates that the pointer does not belong to the client

#include <memory>
void foo()
{
    Album* albumPointer = new Album();
    std::unique_ptr<Album> album(albumPointer);
    album->setName("Unique Album");
}
void foo()
{
    std::unique_ptr<Album> album(new Album());
    bar(std::move(album));
}
void bar(std::unique_ptr<Album> barAlbum)
{
    qDebug() << "Album name" << barAlbum->name();
}

#include <memory>
void foo()
{
std::shared_ptr<Album> album(new Album()); // ref counter = 1
bar(album); // ref counter = 2
} // ref counter = 0
void bar(std::shared_ptr<Album> barAlbum)
{
qDebug() << "Album name" << barAlbum->name();
} // ref counter = 1

#include <memory>
void foo()
{
std::shared_ptr<Album> album(new Album()); // ref counter = 1
bar(std::weak_ptr<Album>(album)); // ref counter = 1
} // ref counter = 0
void bar(std::weak_ptr<Album> barAlbum)
{
qDebug() << "Album name" << barAlbum->name();
} // ref counter = 1

unique_ptr<Album> album = make_unique<Album>();

// In AlbumDao.h
std::unique_ptr<std::vector<std::unique_ptr<Album>>> albums() const;
// In AlbumDao.cpp
unique_ptr<vector<unique_ptr<Album>>> AlbumDao::albums() const
{
    QSqlQuery query("SELECT * FROM albums", mDatabase);
    query.exec();
    unique_ptr<vector<unique_ptr<Album>>> list(new vector<unique_ptr<Album>>
    ());
    while(query.next()) {
        unique_ptr<Album> album(new Album());
        album->setId(query.value("id").toInt());
        album->setName(query.value("name").toString());
        list->push_back(move(album));
    }
    return list;
}
```

* Model/View architecture in Qt with an implementation of the model

```
MVC (Model View Controller)
```

1. The Model manages the data. It is responsible for requesting for the data and updating it.
The View displays the data to the user.  
2. The Controller interacts with both the Model and the View. It is responsible for feeding  
3.the View with the correct data and sending commands to the Model based on the user
interaction received from the View.  

1. QAbstractItemModel: This class is the most abstract, and therefore, the most complex, to
implement. We will have to redefine a lot of functions to properly use it.  
2. QStringListModel: This class is a model that supplies strings to views. It is too simple.
Our model is more complex (we have custom objects).  
3. QSqlTableModel (or QSqLQueryModel): This class is a very interesting contender. It
automatically handles multiple SQL queries. On the other hand, it works only for very
simple table schemas. In the pictures table, for example, the album_id foreign key
makes it very hard to fit this model. You might save some lines of code, but if feels like
trying to shoehorn a round peg into a square hole.  
4. QAbstractListModel: This class provides a model that offers one-dimensional lists. This
fits nicely with our requirements, saves a lot of key strokes, and is still flexible enough.  

```
#include <QAbstractListModel>
#include <QHash>
#include <vector>
#include <memory>
#include "gallery-core_global.h"
#include "Album.h"
#include "DatabaseManager.h"
class GALLERYCORESHARED_EXPORT AlbumModel : public QAbstractListModel
{
Q_OBJECT
    public:
    enum Roles {
        IdRole = Qt::UserRole + 1,
        NameRole,
    };
    AlbumModel(QObject* parent = 0);
    QModelIndex addAlbum(const Album& album);
    int rowCount(const QModelIndex& parent = QModelIndex()) const override;
    QVariant data(const QModelIndex& index, int role = Qt::DisplayRole) const
    override;
    bool setData(const QModelIndex& index, const QVariant& value, int role)
    override;
    bool removeRows(int row, int count, const QModelIndex& parent) override;
    QHash<int, QByteArray> roleNames() const override;
    private:
        bool isIndexValid(const QModelIndex& index) const;
    private:
        DatabaseManager& mDb;
        std::unique_ptr<std::vector<std::unique_ptr<Album>>> mAlbums;
};
```

1. mDb: This is the link to the database. In the Model/View schema, the model will
communicate with the data layer through mDb.  
2. mAlbums: This acts as a buffer that will avoid hitting the database too much. The type
should remind you of what we wrote for AlbumDao::albums() with the smart pointers.

```
AlbumModel::AlbumModel(QObject* parent) :
QAbstractListModel(parent),
mDb(DatabaseManager::instance()),
mAlbums(mDb.albumDao.albums())
{
}
```

 

![qt models](/md_blog/public/assets/2021-07-18/MasteringQt5-models.jpg)

  
1. List Model: In this model, the data is stored in a one-dimensional array (rows)  
2. Table Model: In this model, the data is stored in a two-dimensional array (rows and
columns)  
3. Tree Model: In this model, the data is stored in a hierarchical relationship
(parent/children)  

```
QVariant AlbumModel::data(const QModelIndex& index, int role) const
{
    if (!isIndexValid(index)) {
        return QVariant();
    }
    const Album& album = *mAlbums->at(index.row());
    switch (role) {
    case Roles::IdRole:
        return album.id();
    case Roles::NameRole:
    case Qt::DisplayRole:
        return album.name();
    default:
        return QVariant();
    }
}

QHash<int, QByteArray> AlbumModel::roleNames() const
{
    QHash<int, QByteArray> roles;
    roles[Roles::IdRole] = "id";
    roles[Roles::NameRole] = "name";
    return roles;
}
QModelIndex AlbumModel::addAlbum(const Album& album)
{
    int rowIndex = rowCount();
    beginInsertRows(QModelIndex(), rowIndex, rowIndex);
    unique_ptr<Album> newAlbum(new Album(album));
    mDb.albumDao.addAlbum(*newAlbum);
    mAlbums->push_back(move(newAlbum));
    endInsertRows();
    return index(rowIndex, 0);
}
bool AlbumModel::setData(const QModelIndex& index, const QVariant& value, int
role)
{
    if (!isIndexValid(index)
        || role != Roles::NameRole) {
        return false;
    }
    Album& album = *mAlbums->at(index.row());
    album.setName(value.toString());
    mDb.albumDao.updateAlbum(album);
    emit dataChanged(index, index);
    return true;
}
bool AlbumModel::removeRows(int row, int count, const QModelIndex& parent)
{
    if (row < 0
    || row >= rowCount()
    || count < 0
    || (row + count) > rowCount()) {
        return false;
    }
    beginRemoveRows(parent, row, row + count - 1);
    int countLeft = count;
    while (countLeft--) {
        const Album& album = *mAlbums->at(row + countLeft);
        mDb.albumDao.removeAlbum(album.id());
    }
    mAlbums->erase(mAlbums->begin() + row,
    mAlbums->begin() + row + count);
    endRemoveRows();
    return true;
}

#include <memory>
#include <vector>
#include <QAbstractListModel>
#include "gallery-core_global.h"
#include "Picture.h"
class Album;
class DatabaseManager;
class AlbumModel;
class GALLERYCORESHARED_EXPORT PictureModel : public QAbstractListModel
{
Q_OBJECT
public:
    enum PictureRole {
        FilePathRole = Qt::UserRole + 1
    };
    PictureModel(const AlbumModel& albumModel, QObject* parent = 0);
    QModelIndex addPicture(const Picture& picture);
    int rowCount(const QModelIndex& parent = QModelIndex()) const override;
    QVariant data(const QModelIndex& index, int role) const override;
    bool removeRows(int row, int count, const QModelIndex& parent) override;
    void setAlbumId(int albumId);
    void clearAlbum();
public slots:
    void deletePicturesForAlbum();
private:
    void loadPictures(int albumId);
    bool isIndexValid(const QModelIndex& index) const;
private:
    DatabaseManager& mDb;
    int mAlbumId;
    std::unique_ptr<std::vector<std::unique_ptr<Picture>>> mPictures;
};
PictureModel::PictureModel(const AlbumModel& albumModel, QObject* parent) :
QAbstractListModel(parent),
mDb(DatabaseManager::instance()),
mAlbumId(-1),
mPictures(new vector<unique_ptr<Picture>>())
{
connect(&albumModel, &AlbumModel::rowsRemoved,
this, &PictureModel::deletePicturesForAlbum);
}
void PictureModel::setAlbumId(int albumId)
{
beginResetModel();
mAlbumId = albumId;
loadPictures(mAlbumId);
endResetModel();
}
void PictureModel::loadPictures(int albumId)
{
if (albumId <= 0) {
mPictures.reset(new vector<unique_ptr<Picture>>());
return;
}
mPictures = mDb.pictureDao.picturesForAlbum(albumId);
}
```

* effect 
![](/md_blog/public/assets/2021-07-18/MasteringQt5-image-view.jpg)  
![](/md_blog/public/assets/2021-07-18/MasteringQt5-image-detail.jpg)  
![](/md_blog/public/assets/2021-07-18/MasteringQt5-image-view-structure.jpg)  

* Creating a ThumbnailProxyModel 
The QAbstractProxyModel class has two subclasses:
1. The QIdentityProxyModel subclass proxies its source model without any modification
(all the indexes match). This class is suitable if you want to transform the data()
function.  
2. The QSortFilterProxyModel subclass proxies its source model with the ability to sort
and filter the passing data.  

```
#include <QIdentityProxyModel>
#include <QHash>
#include <QPixmap>
class PictureModel;
class ThumbnailProxyModel : public QIdentityProxyModel
{
public:
    ThumbnailProxyModel(QObject* parent = 0);
    QVariant data(const QModelIndex& index, int role) const override;
    void setSourceModel(QAbstractItemModel* sourceModel) override;
    PictureModel* pictureModel() const;
private:
    void generateThumbnails(const QModelIndex& startIndex, int count);
    void reloadThumbnails();
private:
    QHash<QString, QPixmap*> mThumbnails;
};

const unsigned int THUMBNAIL_SIZE = 350;
...
void ThumbnailProxyModel::generateThumbnails(
    const QModelIndex& startIndex, int
    count)
{
    if (!startIndex.isValid()) {
        return;
    }
    const QAbstractItemModel* model = startIndex.model();
    int lastIndex = startIndex.row() + count;
    for(int row = startIndex.row(); row < lastIndex; row++) {
        QString filepath = model->data(model->index(row, 0),
        PictureModel::Roles::FilePathRole).toString();
        QPixmap pixmap(filepath);
        auto thumbnail = new QPixmap(pixmap
        .scaled(THUMBNAIL_SIZE, THUMBNAIL_SIZE,
        Qt::KeepAspectRatio,
        Qt::SmoothTransformation));
        mThumbnails.insert(filepath, thumbnail);
    }
}
void ThumbnailProxyModel::reloadThumbnails()
{
    qDeleteAll(mThumbnails);
    mThumbnails.clear();
    generateThumbnails(index(0, 0), rowCount());
}
void ThumbnailProxyModel::setSourceModel(QAbstractItemModel* sourceModel)
{
    QIdentityProxyModel::setSourceModel(sourceModel);
    if (!sourceModel) {
        return;
    }
    connect(sourceModel, &QAbstractItemModel::modelReset,
        [this] {
            reloadThumbnails();
    });
    connect(sourceModel, &QAbstractItemModel::rowsInserted,
        [this] (const QModelIndex& parent, int first, int last) {
            generateThumbnails(index(first, 0), last - first + 1);
    });
}
QVariant ThumbnailProxyModel::data(const QModelIndex& index, int role) const
{
    if (role != Qt::DecorationRole) {
        return QIdentityProxyModel::data(index, role);
    }
    QString filepath = sourceModel()->data(index,
        PictureModel::Roles::FilePathRole).toString();
    return *mThumbnails[filepath];
}
PictureModel* ThumbnailProxyModel::pictureModel() const
{
    return static_cast<PictureModel*>(sourceModel());
}

#include <QWidget>
#include <QModelIndex>
namespace Ui {
class AlbumWidget;
}
class AlbumModel;
class PictureModel;
class QItemSelectionModel;
class ThumbnailProxyModel;
class AlbumWidget : public QWidget
{
Q_OBJECT
public:
explicit AlbumWidget(QWidget *parent = 0);
~AlbumWidget();
void setAlbumModel(AlbumModel* albumModel);
void setAlbumSelectionModel(QItemSelectionModel* albumSelectionModel);
void setPictureModel(ThumbnailProxyModel* pictureModel);
void setPictureSelectionModel(QItemSelectionModel* selectionModel);
signals:
void pictureActivated(const QModelIndex& index);
private slots:
void deleteAlbum();
void editAlbum();
void addPictures();
private:
void clearUi();
void loadAlbum(const QModelIndex& albumIndex);
private:
Ui::AlbumWidget* ui;
AlbumModel* mAlbumModel;
QItemSelectionModel* mAlbumSelectionModel;
ThumbnailProxyModel* mPictureModel;
QItemSelectionModel* mPictureSelectionModel;
};
#include "AlbumWidget.h"
#include "ui_AlbumWidget.h"
#include <QInputDialog>
#include <QFileDialog>
#include "AlbumModel.h"
#include "PictureModel.h"
AlbumWidget::AlbumWidget(QWidget *parent) :
QWidget(parent),
ui(new Ui::AlbumWidget),
mAlbumModel(nullptr),
mAlbumSelectionModel(nullptr),
mPictureModel(nullptr),
mPictureSelectionModel(nullptr)
{
ui->setupUi(this);
clearUi();
ui->thumbnailListView->setSpacing(5);
ui->thumbnailListView->setResizeMode(QListView::Adjust);
ui->thumbnailListView->setFlow(QListView::LeftToRight);
ui->thumbnailListView->setWrapping(true);
connect(ui->thumbnailListView, &QListView::doubleClicked,
this, &AlbumWidget::pictureActivated);
connect(ui->deleteButton, &QPushButton::clicked,
this, &AlbumWidget::deleteAlbum);
connect(ui->editButton, &QPushButton::clicked,
this, &AlbumWidget::editAlbum);
connect(ui->addPicturesButton, &QPushButton::clicked,
this, &AlbumWidget::addPictures);
}
AlbumWidget::~AlbumWidget()
{
delete ui;
}

void AlbumWidget::setAlbumModel(AlbumModel* albumModel)
{
mAlbumModel = albumModel;
connect(mAlbumModel, &QAbstractItemModel::dataChanged,
[this] (const QModelIndex &topLeft) {
if (topLeft == mAlbumSelectionModel->currentIndex()) {
loadAlbum(topLeft);
}
});
}
void AlbumWidget::setAlbumSelectionModel(QItemSelectionModel*
albumSelectionModel)
{
mAlbumSelectionModel = albumSelectionModel;
connect(mAlbumSelectionModel,
&QItemSelectionModel::selectionChanged,
[this] (const QItemSelection &selected) {
if (selected.isEmpty()) {
clearUi();
return;
}
loadAlbum(selected.indexes().first());
});
}
void AlbumWidget::setPictureModel(PictureModel* pictureModel)
{
mPictureModel = pictureModel;
ui->thumbnailListView->setModel(mPictureModel);
}
void AlbumWidget::setPictureSelectionModel(QItemSelectionModel* selectionModel)
{
ui->thumbnailListView->setSelectionModel(selectionModel);
}
void AlbumWidget::deleteAlbum()
{
if (mAlbumSelectionModel->selectedIndexes().isEmpty()) {
return;
}
int row = mAlbumSelectionModel->currentIndex().row();
mAlbumModel->removeRow(row);
// Try to select the previous album
QModelIndex previousModelIndex = mAlbumModel->index(row - 1,
0);
if(previousModelIndex.isValid()) {
mAlbumSelectionModel->setCurrentIndex(previousModelIndex,
QItemSelectionModel::SelectCurrent);
return;
}
// Try to select the next album
QModelIndex nextModelIndex = mAlbumModel->index(row, 0);
if(nextModelIndex.isValid()) {
mAlbumSelectionModel->setCurrentIndex(nextModelIndex,
QItemSelectionModel::SelectCurrent);
return;
}
}
void AlbumWidget::editAlbum()
{
if (mAlbumSelectionModel->selectedIndexes().isEmpty()) {
return;
}
QModelIndex currentAlbumIndex =
mAlbumSelectionModel->selectedIndexes().first();
QString oldAlbumName = mAlbumModel->data(currentAlbumIndex,
AlbumModel::Roles::NameRole).toString();
bool ok;
QString newName = QInputDialog::getText(this,
"Album's name",
"Change Album name",
QLineEdit::Normal,
oldAlbumName,
&ok);
if (ok && !newName.isEmpty()) {
mAlbumModel->setData(currentAlbumIndex,
newName,
AlbumModel::Roles::NameRole);
}
}
void AlbumWidget::addPictures()
{
QStringList filenames =
QFileDialog::getOpenFileNames(this,
"Add pictures",
QDir::homePath(),
"Picture files (*.jpg *.png)");
if (!filenames.isEmpty()) {
QModelIndex lastModelIndex;
for (auto filename : filenames) {
Picture picture(filename);
lastModelIndex = mPictureModelâ†’pictureModel()-
>addPicture(picture);
}
ui->thumbnailListView->setCurrentIndex(lastModelIndex);
}
}

void AlbumWidget::clearUi()
{
ui->albumName->setText("");
ui->deleteButton->setVisible(false);
ui->editButton->setVisible(false);
ui->addPicturesButton->setVisible(false);
}
void AlbumWidget::loadAlbum(const QModelIndex& albumIndex)
{
mPictureModel->pictureModel()->setAlbumId(mAlbumModel->data(albumIndex,
AlbumModel::Roles::IdRole).toInt());
ui->albumName->setText(mAlbumModel->data(albumIndex,
Qt::DisplayRole).toString());
ui->deleteButton->setVisible(true);
ui->editButton->setVisible(true);
ui->addPicturesButton->setVisible(true);
}

#include <QStyledItemDelegate>
class PictureDelegate : public QStyledItemDelegate
{
Q_OBJECT
public:
PictureDelegate(QObject* parent = 0);
void paint(QPainter* painter, const QStyleOptionViewItem&
option, const QModelIndex& index) const override;
QSize sizeHint(const QStyleOptionViewItem& option,
const QModelIndex& index) const override;
};
#include "PictureDelegate.h"
#include <QPainter>
const unsigned int BANNER_HEIGHT = 20;
const unsigned int BANNER_COLOR = 0x303030;
const unsigned int BANNER_ALPHA = 200;
const unsigned int BANNER_TEXT_COLOR = 0xffffff;
const unsigned int HIGHLIGHT_ALPHA = 100;
PictureDelegate::PictureDelegate(QObject* parent) :
QStyledItemDelegate(parent)
{
}
void PictureDelegate::paint(QPainter* painter, const QStyleOptionViewItem&
option, const QModelIndex& index) const
{
painter->save();
QPixmap pixmap = index.model()->data(index,
Qt::DecorationRole).value<QPixmap>();
painter->drawPixmap(option.rect.x(), option.rect.y(), pixmap);
QRect bannerRect = QRect(option.rect.x(), option.rect.y(),
pixmap.width(), BANNER_HEIGHT);
QColor bannerColor = QColor(BANNER_COLOR);
bannerColor.setAlpha(BANNER_ALPHA);
painter->fillRect(bannerRect, bannerColor);
QString filename = index.model()->data(index,
Qt::DisplayRole).toString();
painter->setPen(BANNER_TEXT_COLOR);
painter->drawText(bannerRect, Qt::AlignCenter, filename);
if (option.state.testFlag(QStyle::State_Selected)) {
QColor selectedColor = option.palette.highlight().color();
selectedColor.setAlpha(HIGHLIGHT_ALPHA);
painter->fillRect(option.rect, selectedColor);
}
painter->restore();
}
QSize PictureDelegate::sizeHint(const QStyleOptionViewItem& /*option*/, const
QModelIndex& index) const
{
const QPixmap& pixmap = index.model()->data(index,
Qt::DecorationRole).value<QPixmap>();
return pixmap.size();
}

AlbumWidget::AlbumWidget(QWidget *parent) :
QWidget(parent),
ui(new Ui::AlbumWidget),
mAlbumModel(nullptr),
mAlbumSelectionModel(nullptr),
mPictureModel(nullptr),
mPictureSelectionModel(nullptr)
{
ui->setupUi(this);
clearUi();
ui->thumbnailListView->setSpacing(5);
ui->thumbnailListView->setResizeMode(QListView::Adjust);
ui->thumbnailListView->setFlow(QListView::LeftToRight);
ui->thumbnailListView->setWrapping(true);
ui->thumbnailListView->setItemDelegate(
new PictureDelegate(this));
...
}

#include <QWidget>
#include <QItemSelection>
namespace Ui {
class PictureWidget;
}
class PictureModel;
class QItemSelectionModel;
class ThumbnailProxyModel;
class PictureWidget : public QWidget
{
Q_OBJECT
public:
explicit PictureWidget(QWidget *parent = 0);
~PictureWidget();
void setModel(ThumbnailProxyModel* model);
void setSelectionModel(QItemSelectionModel* selectionModel);
signals:
void backToGallery();
protected:
void resizeEvent(QResizeEvent* event) override;
private slots:
void deletePicture();
void loadPicture(const QItemSelection& selected);
private:
void updatePicturePixmap();
private:
Ui::PictureWidget* ui;
ThumbnailProxyModel* mModel;
QItemSelectionModel* mSelectionModel;
QPixmap mPixmap;
};

void PictureWidget::resizeEvent(QResizeEvent* event)
{
QWidget::resizeEvent(event);
updatePicturePixmap();
}
void PictureWidget::updatePicturePixmap()
{
if (mPixmap.isNull()) {
return;
}
ui->pictureLabel->setPixmap(mPixmap.scaled(ui->pictureLabel->size(),
Qt::KeepAspectRatio));
}

```

* custom plugin widget  
![](/md_blog/public/assets/2021-07-18/MasteringQt5-custom-plugin.jpg) 
* Animation  
Three main classes are provided to build animations:
1. QPropertyAnimation: This class animates one Qt property animation  
2. QParallelAnimationGroup: This class animates multiple animations in parallel (all the
animations start together)  
3. QSequentialAnimationGroup: This class animates multiple animations in sequence (the
animations run one by one in a defined order) 
All those classes inherit QAbstractAnimation.  
![](/md_blog/public/assets/2021-07-18/MasteringQt5-animation.jpg) 

```
QLabel label;
QPropertyAnimation animation;
animation.setTargetObject(&label);
animation.setPropertyName("geometry");
animation.setDuration(4000);
animation.setStartValue(QRect(0, 0, 150, 50));
animation.setEndValue(QRect(300, 200, 150, 50));
animation.start();
```

```
QLabel label;
QPropertyAnimation animation(&label, "geometry");
animation.setDuration(4000);
animation.setStartValue(QRect(0, 0, 150, 50));
animation.setEndValue(QRect(300, 200, 150, 50));
animation.setEasingCurve(QEasingCurve::InCirc);
animation.start();
```

```
QLabel label;
QPropertyAnimation animation(&label, "geometry");
animation.setDuration(4000);
animation.setKeyValueAt(0, QRect(0, 0, 150, 50));
animation.setKeyValueAt(0.25, QRect(225, 112.5, 150, 50));
animation.setKeyValueAt(1, QRect(300, 200, 150, 50));
animation.start();
```

```
QPropertyAnimation animation1(&label1, "geometry");
QPropertyAnimation animation2(&label2, "geometry");
...
QSequentialAnimationGroup animationGroup;
animationGroup.addAnimation(&anim1);
animationGroup.addAnimation(&anim2);
animationGroup.start();
```

1. jump
2. flash
* Multithreading  
1. Deep understanding of the QThread framework 

```
QThread thread;
thread.start();
class Thread : public QThread
{
Q_OBJECT
protected:
void run()
{
Object* myObject = new Object();
connect(myObject, &Object::started,
this, &Thread::doWork);
exec();
}
private slots:
void doWork();
};

class Thread : public QThread
{
Thread() :
mObject(new QObject())
{
}
private :
QObject* myObject;
};
// Somewhere in MainWindow
Thread thread;
thread.start();

class Thread : public QThread
{
Q_OBJECT
void run() {
// long running operation
emit result("I <3 threads");
}
signals:
void result(QString data);
};
// Somewhere in MainWindow
Thread* thread = new Thread(this);
connect(thread, &Thread::result, this, &MainWindow::handleResult);
connect(thread, &Thread::finished, thread, &QObject::deleteLater);
thread->start();
```

```
QObject::connect(
const QObject *sender, const char *signal,
const QObject *receiver, const char *method,
Qt::ConnectionType type = Qt::AutoConnection)
```

1. The type keyword takes Qt:: AutoConnection as a default value. Let's review the possible
values of the Qt:: ConectionType enum as the official Qt documentation states:
Qt:: AutoConnection: If the receiver lives in the thread that emits the
signal, Qt:: DirectConnection is used. Otherwise, Qt:: QueuedConnection is used. The
connection type is determined when the signal is emitted.  
2. Qt:: DirectConnection: This slot is invoked immediately when the signal is emitted. The
slot is executed in the signaling thread.  
3. Qt:: QueuedConnection: This slot is invoked when control returns to the event loop of the
receiver's thread. The slot is executed in the receiver's thread.  
4. Qt:: BlockingQueuedConnection: This is the same as Qt:: QueuedConnection, except that
the signaling thread blocks until the slot returns. This connection must not be used if the
receiver lives in the signaling thread, or else the application will deadlock.    
5. Qt:: UniqueConnection: This is a flag that can be combined with any one of the previous
connection types, using a bitwise OR. When Qt:: UniqueConnection is
set, QObject::connect() will fail if the connection already exists (that is, if the same
signal is already connected to the same slot for the same pair of objects).  

```
connect(thread, &Thread::result,
this, &MainWindow::handleResult);
```

When result() is emitted, Qt will look at the handleResult() thread affinity, which is
different from the thread affinity of the result() signal. The thread object is living
in MainWindow (remember that it has been created in MainWindow), but the result() signal has
been emitted in the run() function, which is running in a different thread of execution. As a
result, a Qt:: QueuedConnection slot will be used.
We can now take a look at the second connect():

```
connect(thread, &Thread::finished, thread, &QObject::deleteLater);
```

Here, deleteLater() and finished() live in the same thread; therefore, 
a Qt:: DirectConnection slot will be used.

```
class Thread : public QThread
{
Q_OBJECT
protected:
void run()
{
Object* myObject = new Object();
connect(myObject, &Object::started,
this, &Thread::doWork);
exec();
}
private slots:
void doWork();
};
```

This system is powerful, but complex. To make things simpler, Qt favors the worker model. It
splits the threading plumbing from the real processing. Here is an example:

```
class Worker : public QObject
{
Q_OBJECT
public slots:
void doWork()
{
emit result("workers are the best");
}
signals:
void result(QString data);
};
// Somewhere in MainWindow
QThread* thread = new Thread(this);
Worker* worker = new Worker();
worker->moveToThread(thread);
connect(thread, &QThread::finished,
worker, &QObject::deleteLater);
connect(this, &MainWindow::startWork,
worker, &Worker::doWork);
connect(worker, &Worker::resultReady,
this, handleResult);
thread->start();
// later on, to stop the thread
thread->quit();
thread->wait();
```

Flying over Qt multithreading

```
QMutex mutex;
int number = 1;
mutex.lock();
number *= 2;
mutex.unlock();

QMutex mutex;
QMutexLocker locker(&mutex);
int number = 1;
number *= 2;
if (overlyComplicatedCondition) {
return;
} else if (notSoSimple) {
return;
}

class Job : public QRunnable
{
void run()
{
// long running operation
}
}
Job* job = new Job();
QThreadPool::globalInstance()->start(job);
```

Just override the run() function and ask QThreadPool to execute your job in a separate thread.
The QThreadPool::globalInstance() is a static helper function that gives you access to an
application global instance. You can create your own QThreadPool if you need to have finer
control over the QThreadPool life cycle.
Note that the QThreadPool::start() function takes the ownership of job and will
automatically delete it when run() finishes. Watch out, this does not change the thread affinity
like QObject::moveToThread() does with workers! A QRunnable class cannot be reused, it has
to be a freshly baked instance.

```
void longRunningFunction();
QFuture<void> future = QtConcurrent::run(longRunningFunction);

QImage processGrayscale(QImage& image);
QImage lenna;
QFuture<QImage> future = QtConcurrent::run(processGrayscale,
lenna);
QImage grayscaleLenna = future.result();
```

To avoid blocking, QFutureWatcher comes to the rescue:

```
connect(&watcher, &QFutureWatcher::finished,
this, &QObject::handleGrayscale);
QImage processGrayscale(QImage& image);
QImage lenna;
QFuture<QImage> future = QtConcurrent::run(processImage, lenna);
watcher.setFuture(future);

QList images = ...;
QImage processGrayscale(QImage& image);
QFuture<void> future = QtConcurrent::mapped(
images, processGrayscale);

QList images = ...;
QImage processGrayscale(QImage& image);
void combineImage(QImage& finalImage, const QImage& inputImage);
QFuture<void> future = QtConcurrent::mappedReduced(
    images,
    processGrayscale,
    combineImage);
```

![](/md_blog/public/assets/2021-07-18/MasteringQt5-thread-example.jpg)

```
#include <QSize>
#include <QVector>
#include <QPointF>
struct JobResult
{
JobResult(int valueCount = 1) :
areaSize(0, 0),
pixelPositionY(0),
moveOffset(0, 0),
scaleFactor(0.0),
values(valueCount)
{
}
QSize areaSize;
int pixelPositionY;
QPointF moveOffset;
double scaleFactor;
QVector<int> values;
};
#include <QObject>
#include <QRunnable>
#include "JobResult.h"
class Job : public QObject, public QRunnable
{
Q_OBJECT
public:
Job(QObject *parent = 0);
void run() override;
};
#include <QObject>
#include <QRunnable>
#include <QPointF>
#include <QSize>
#include <QAtomicInteger>
class Job : public QObject, public QRunnable
{
Q_OBJECT
public:
Job(QObject *parent = 0);
void run() override;
void setPixelPositionY(int value);
void setMoveOffset(const QPointF& value);
void setScaleFactor(double value);
void setAreaSize(const QSize& value);
void setIterationMax(int value);
private:
int mPixelPositionY;
QPointF mMoveOffset;
double mScaleFactor;
QSize mAreaSize;
int mIterationMax;
};
#include <QObject>
#include <QRunnable>
#include <QPointF>
#include <QSize>
#include <QAtomicInteger>
#include "JobResult.h"
class Job : public QObject, public QRunnable
{
Q_OBJECT
public:
...
signals:
void jobCompleted(JobResult jobResult);
public slots:
void abort();
private:
QAtomicInteger<bool> mAbort;
...
};
#include "Job.h"
Job::Job(QObject* parent) :
QObject(parent),
mAbort(false),
mPixelPositionY(0),
mMoveOffset(0.0, 0.0),
mScaleFactor(0.0),
mAreaSize(0, 0),
mIterationMax(1)
{
}
void Job::run()
{
JobResult jobResult(mAreaSize.width());
jobResult.areaSize = mAreaSize;
jobResult.pixelPositionY = mPixelPositionY;
jobResult.moveOffset = mMoveOffset;
jobResult.scaleFactor = mScaleFactor;
...
}
void Job::run()
{
...
double imageHalfWidth = mAreaSize.width() / 2.0;
double imageHalfHeight = mAreaSize.height() / 2.0;
for (int imageX = 0; imageX < mAreaSize.width(); ++imageX) {
int iteration = 0;
double x0 = (imageX - imageHalfWidth)
* mScaleFactor + mMoveOffset.x();
double y0 = (mPixelPositionY - imageHalfHeight)
* mScaleFactor - mMoveOffset.y();
double x = 0.0;
double y = 0.0;
do {
if (mAbort.load()) {
return;
}
double nextX = (x * x) - (y * y) + x0;
y = 2.0 * x * y + y0;
x = nextX;
iteration++;
} while(iteration < mIterationMax
&& (x * x) + (y * y) < 4.0);
jobResult.values[imageX] = iteration;
}
emit jobCompleted(jobResult);
}
void Job::abort()
{
mAbort.store(true);
}
```

Using QThreadPool

```
#include <QObject>
#include <QSize>
#include <QPointF>
#include <QElapsedTimer>
#include <QList>
#include "JobResult.h"
class Job;
class MandelbrotCalculator : public QObject
{
Q_OBJECT
public:
explicit MandelbrotCalculator(QObject *parent = 0);
void init(QSize imageSize);
private:
QPointF mMoveOffset;
double mScaleFactor;
QSize mAreaSize;
int mIterationMax;
int mReceivedJobResults;
QList<JobResult> mJobResults;
QElapsedTimer mTimer;
};
...
class MandelbrotCalculator : public QObject
{
Q_OBJECT
public:
explicit MandelbrotCalculator(QObject *parent = 0);
void init(QSize imageSize);
signals:
void pictureLinesGenerated(QList<JobResult> jobResults);
void abortAllJobs();
public slots:
void generatePicture(QSize areaSize, QPointF moveOffset,
double scaleFactor, int iterationMax);
void process(JobResult jobResult);
private:
Job* createJob(int pixelPositionY);
void clearJobs();
private:
...
};
#include <QDebug>
#include <QThreadPool>
#include "Job.h"
const int JOB_RESULT_THRESHOLD = 10;
MandelbrotCalculator::MandelbrotCalculator(QObject *parent)
: QObject(parent),
mMoveOffset(0.0, 0.0),
mScaleFactor(0.005),
mAreaSize(0, 0),
mIterationMax(10),
mReceivedJobResults(0),
mJobResults(),
mTimer()
{
}
void MandelbrotCalculator::generatePicture(QSize areaSize, QPointF moveOffset,
double scaleFactor, int iterationMax)
{
if (areaSize.isEmpty()) {
return;
}
mTimer.start();
clearJobs();
mAreaSize = areaSize;
mMoveOffset = moveOffset;
mScaleFactor = scaleFactor;
mIterationMax = iterationMax;
for(int pixelPositionY = 0;
pixelPositionY < mAreaSize.height(); pixelPositionY++) {
QThreadPool::globalInstance()->
start(createJob(pixelPositionY));
}
}
Job* MandelbrotCalculator::createJob(int pixelPositionY)
{
Job* job = new Job();
job->setPixelPositionY(pixelPositionY);
job->setMoveOffset(mMoveOffset);
job->setScaleFactor(mScaleFactor);
job->setAreaSize(mAreaSize);
job->setIterationMax(mIterationMax);
connect(this, &MandelbrotCalculator::abortAllJobs,
job, &Job::abort);
connect(job, &Job::jobCompleted,
this, &MandelbrotCalculator::process);
return job;
}
void MandelbrotCalculator::clearJobs()
{
mReceivedJobResults = 0;
emit abortAllJobs();
QThreadPool::globalInstance()->clear();
}
void MandelbrotCalculator::process(JobResult jobResult)
{
if (jobResult.areaSize != mAreaSize ||
jobResult.moveOffset != mMoveOffset ||
jobResult.scaleFactor != mScaleFactor) {
return;
}
mReceivedJobResults++;
mJobResults.append(jobResult);
if (mJobResults.size() >= JOB_RESULT_THRESHOLD ||
mReceivedJobResults == mAreaSize.height()) {
emit pictureLinesGenerated(mJobResults);
mJobResults.clear();
}
if (mReceivedJobResults == mAreaSize.height()) {
qDebug() << "Generated in " << mTimer.elapsed() << " ms";
}
}
```

Displaying the fractal

```
#include <memory>
#include <QWidget>
#include <QPoint>
#include <QThread>
#include <QList>
#include "MandelbrotCalculator.h"
class QResizeEvent;
class MandelbrotWidget : public QWidget
{
Q_OBJECT
public:
explicit MandelbrotWidget(QWidget *parent = 0);
~MandelbrotWidget();
private:
MandelbrotCalculator mMandelbrotCalculator;
QThread mThreadCalculator;
double mScaleFactor;
QPoint mLastMouseMovePosition;
QPointF mMoveOffset;
QSize mAreaSize;
int mIterationMax;
std::unique_ptr<QImage> mImage;
};
class MandelbrotWidget : public QWidget
{
...
public slots:
void processJobResults(QList<JobResult> jobResults);
signals:
void requestPicture(QSize areaSize, QPointF moveOffset, double scaleFactor,
int iterationMax);
protected:
void paintEvent(QPaintEvent*) override;
void resizeEvent(QResizeEvent* event) override;
void wheelEvent(QWheelEvent* event) override;
void mousePressEvent(QMouseEvent* event) override;
void mouseMoveEvent(QMouseEvent* event) override;
private:
QRgb generateColorFromIteration(int iteration);
private:
...
};
#include "MandelbrotWidget.h"
#include <QResizeEvent>
#include <QImage>
#include <QPainter>
#include <QtMath>
const int ITERATION_MAX = 4000;
const double DEFAULT_SCALE = 0.005;
const double DEFAULT_OFFSET_X = -0.74364390249094747;
const double DEFAULT_OFFSET_Y = 0.13182589977450967;
MandelbrotWidget::MandelbrotWidget(QWidget *parent) :
QWidget(parent),
mMandelbrotCalculator(),
mThreadCalculator(this),
mScaleFactor(DEFAULT_SCALE),
mLastMouseMovePosition(),
mMoveOffset(DEFAULT_OFFSET_X, DEFAULT_OFFSET_Y),
mAreaSize(),
mIterationMax(ITERATION_MAX)
{
mMandelbrotCalculator.moveToThread(&mThreadCalculator);
connect(this, &MandelbrotWidget::requestPicture,
&mMandelbrotCalculator,
&MandelbrotCalculator::generatePicture);
connect(&mMandelbrotCalculator,
&MandelbrotCalculator::pictureLinesGenerated,
this, &MandelbrotWidget::processJobResults);
mThreadCalculator.start();
}
MandelbrotWidget::~MandelbrotWidget()
{
mThreadCalculator.quit();
mThreadCalculator.wait(1000);
if (!mThreadCalculator.isFinished()) {
mThreadCalculator.terminate();
}
}
void MandelbrotWidget::resizeEvent(QResizeEvent* event)
{
mAreaSize = event->size();
mImage = std::make_unique<QImage>(mAreaSize,
QImage::Format_RGB32);
mImage->fill(Qt::black);
emit requestPicture(mAreaSize, mMoveOffset, mScaleFactor,
mIterationMax);
}
void MandelbrotWidget::wheelEvent(QWheelEvent* event)
{
int delta = event->delta();
mScaleFactor *= qPow(0.75, delta / 120.0);
emit requestPicture(mAreaSize, mMoveOffset, mScaleFactor,
mIterationMax);
}
void MandelbrotWidget::mousePressEvent(QMouseEvent* event)
{
if (event->buttons() & Qt::LeftButton) {
mLastMouseMovePosition = event->pos();
}
}
void MandelbrotWidget::mouseMoveEvent(QMouseEvent* event)
{
if (event->buttons() & Qt::LeftButton) {
QPointF offset = event->pos() - mLastMouseMovePosition;
mLastMouseMovePosition = event->pos();
offset.setY(-offset.y());
mMoveOffset += offset * mScaleFactor;
emit requestPicture(mAreaSize, mMoveOffset, mScaleFactor,
mIterationMax);
}
}
void MandelbrotWidget::processJobResults(QList<JobResult> jobResults)
{
int yMin = height();
int yMax = 0;
for(JobResult& jobResult : jobResults) {
if (mImage->size() != jobResult.areaSize) {
continue;
}
int y = jobResult.pixelPositionY;
QRgb* scanLine =
reinterpret_cast<QRgb*>(mImage->scanLine(y));
for (int x = 0; x < mAreaSize.width(); ++x) {
scanLine[x] =
generateColorFromIteration(jobResult.values[x]);
}
if (y < yMin) {
yMin = y;
}
if (y > yMax) {
yMax = y;
}
}
repaint(0, yMin,
width(), yMax);
}
QRgb MandelbrotWidget::generateColorFromIteration(int iteration)
{
if (iteration == mIterationMax) {
return qRgb(50, 50, 255);
}
return qRgb(0, 0, (255.0 * iteration / mIterationMax));
}
void MandelbrotWidget::paintEvent(QPaintEvent* event)
{
QPainter painter(this);
painter.save();
QRect imageRect = event->region().boundingRect();
painter.drawImage(imageRect, *mImage, imageRect);
painter.setPen(Qt::white);
painter.drawText(10, 20, QString("Size: %1 x %2")
.arg(mImage->width())
.arg(mImage->height()));
painter.drawText(10, 35, QString("Offset: %1 x %2")
.arg(mMoveOffset.x())
.arg(mMoveOffset.y()));
painter.drawText(10, 50, QString("Scale: %1")
.arg(mScaleFactor));
painter.drawText(10, 65, QString("Max iteration: %1")
.arg(ITERATION_MAX));
painter.restore();
}
```

2. Overview of all the available threading technologies in Qt  
3. Using a QThreadPool class to dispatch jobs and aggregate the results  
4. How to synchronize threads and minimize sharing states  
5. Low-level drawing to optimize the performances  
6. Common threading pitfalls and challenges   
* IPC 
1. How two applications can communicate together  
2. Creating a multithreaded TCP server  
3. Reading and writing on a TCP socket  
4. Other IPC techniques like QSharedMemory, QProcess, and Qt D-Bus  
5. Network serialization using QDataStream  
6. Computer clustering  
7. Inter-process communication techniques  

```
QTcpServer* tcpServer = new QTcpServer(this);
tcpServer->listen(QHostAddress::Any, 5000);
connect(tcpServer, &QTcpServer::newConnection, [tcpServer] {
QTcpSocket *tcpSocket = tcpServer->nextPendingConnection();
QByteArray response = QString("Hello").toLatin1();
tcpSocket->write(response);
tcpSocket->disconnectFromHost();
qDebug() << "Send response and close the socket";
});
```

```
QTcpSocket *tcpSocket = new QTcpSocket(this);
tcpSocket->connectToHost("127.0.0.1", 5000);
connect(tcpSocket, &QTcpSocket::connected, [tcpSocket] {
qDebug() << "connected";
});
connect(tcpSocket, &QTcpSocket::readyRead, [tcpSocket] {
qDebug() << QString::fromLatin1(tcpSocket->readAll());
});
connect(tcpSocket, &QTcpSocket::disconnected, [tcpSocket] {
qDebug() << "disconnected";
});
```

```
QString sharedMessage("Hello");
QByteArray sharedData = sharedMessage.toLatin1();
QSharedMemory* sharedMemory = new QSharedMemory(
"sharedMemoryKey", this);
sharedMemory->create(sharedMessage.size());
sharedMemory->lock();
memcpy(sharedMemory->data(),
sharedData.data(),
sharedData.size());
sharedMemory->unlock();
```

```
QSharedMemory* sharedMemory = new QSharedMemory(
"sharedMemoryKey", this);
sharedMemory->attach();
sharedMemory->lock();
QByteArray sharedData(sharedMemory->size(), '\0');
memcpy(sharedData.data(),
sharedMemory->data(),
sharedMemory->size());
sharedMemory->unlock();
QString sharedMessage = QString::fromLatin1(sharedData);
qDebug() << sharedMessage;
sharedMemory->detach();
```

```
QTextStream out(stdout);
QTextStream in(stdin);
out << QString("Please enter your name:\n");
out.flush();
QString name = in.readLine();
out << "Hello " << name << "\n";
return 0;
```

```
QProcess* childProcess = new QProcess(this);
connect(childProcess,
&QProcess::readyReadStandardOutput, [childProcess] {
qDebug().noquote() << "[*]" << childProcess->readAll();
});
connect(childProcess, &QProcess::started, [childProcess] {
childProcess->write("Sophie\n");
});
childProcess->start("/path/to/hello");
```

The last IPC mechanism that we will cover together is the D-Bus protocol. Currently, the Qt
D-Bus module is officially supported only on Linux. If you need to use it on Windows, you
will have to compile it from Qt sources. It can be seen as a unified protocol for IPC and RPC
(remote procedure calling). Many forms of communication are possible, such as:  
1. One-to-one  
2. One-to-many  
3. Many-to-many  
Here are the main concepts of D-Bus:
1. Bus: This is used in many-to-many communication. D-Bus defines two buses: the system
bus and the session bus.  
2. Service name: This is the identifier of a service on a bus.  
3. Message: This is a message sent by one application. If a bus is used, the message contains
the destination.  

```
//HelloService.h
class HelloService : public QObject
{
Q_OBJECT
public slots:
QString sayHello(const QString &name);
};
//HelloService.cpp
QString HelloService::sayHello(const QString& name)
{
qDebug().noquote() << name << " is here!";
return QString("Hello %1!").arg(name);;
}
```

```
HelloService helloService;
QString serviceName("org.masteringqt.QtDBus.HelloService");
QDBusConnection::sessionBus().registerService(serviceName);
QDBusConnection::sessionBus().registerObject("/",
&helloService, QDBusConnection::ExportAllSlots);
```

```
QString serviceName("org.masteringqt.QtDBus.HelloService");
QDBusInterface serviceInterface(serviceName, "/");
QDBusReply<QString> response = serviceInterface.call(
"sayHello", "Lenna");
qDebug().noquote() << response;
```

* dbus example  
![](/md_blog/public/assets/2021-07-18/MasteringQt5-dbus-example)
![](/md_blog/public/assets/2021-07-18/MasteringQt5-dbus-example-sdk.jpg)
![](/md_blog/public/assets/2021-07-18/MasteringQt5-dbus-example-worker.jpg)
![](/md_blog/public/assets/2021-07-18/MasteringQt5-dbus-example-app.jpg)

* Having Fun with Serialization 
This chapter will cover the following topics:
1. How to architecture an application that plays and records sounds  
2. The QVariant class and its inner mechanics  
3. A flexible serialization system  
4. JSON serialization  
5. XML serialization  
6. Binary serialization  
7. The Qt Multimedia framework  
8. Drag and drop handling with Qt  
9. Triggering a button from your keyboard   

* You Shall (Not) Pass with QTest
This chapter will cover the following topics:
1. Qt Test framework  
2. Project layout for unit tests  
3. Personalize your test execution  
4. Write tests with datasets  
5. Benchmark your code  
6. Simulating GUI events  

```
#include <QTest>
#include "MainWindow.h"
class TestGui : public QObject
{
Q_OBJECT
public:
TestGui(QObject* parent = 0);
private:
MainWindow mMainWindow;
};
```

```
#include <QtTest/QtTest>
TestGui::TestGui(QObject* parent) :
QObject(parent),
mMainWindow()
{
QTestEventLoop::instance().enterLoop(1);
}
```

```
// In TestGui.h
class TestGui : public QObject
{
...
private slots:
void controlButtonState();
...
};
// In TestGui.cpp
#include <QtTest/QtTest>
#include <QPushButton>
...
void TestGui::controlButtonState()
{
QPushButton* stopButton =
mMainWindow.findChild<QPushButton*>("stopButton");
QPushButton* playButton =
mMainWindow.findChild<QPushButton*>("playButton");
QPushButton* recordButton =
mMainWindow.findChild<QPushButton*>("recordButton");
QTest::mouseClick(recordButton, Qt::LeftButton);
QCOMPARE(stopButton->isEnabled(), true);
QCOMPARE(playButton->isEnabled(), false);
QCOMPARE(recordButton->isEnabled(), false);
}
```

7. Perform signal introspection with the QSignalSpy class  

```
#include <QTest>
#include "MainWindow.h"
// In TestGui.h
class TestGui : public QObject
{
...
void controlButtonState();
void playSound();
...
};
// In TestGui.cpp
#include <QPushButton>
#include <QtTest/QtTest>
#include "SoundEffectWidget.h"
...
void TestGui::playSound()
{
SoundEffectWidget widget;
QSignalSpy spy(&widget, &SoundEffectWidget::soundPlayed);
widget.setId(2);
widget.play();
QCOMPARE(spy.count(), 1);
QList<QVariant> arguments = spy.takeFirst();
QCOMPARE(arguments.at(0).toInt(), 2);
}
```

* Packed and Ready to Deploy  

```
Create a file, package-windows.bat, in the scripts directory:
@ECHO off
set DIST_DIR=dist\desktop-windows
set BUILD_DIR=build
set OUT_DIR=gallery
mkdir %DIST_DIR% && pushd %DIST_DIR%
mkdir %BUILD_DIR% %OUT_DIR%
pushd %BUILD_DIR%
%QTDIR%\bin\qmake.exe ^
-spec win32-g++ ^
"CONFIG += release" ^
..\..\..\ch13-gallery-packaging.pro
%MINGWROOT%\bin\mingw32-make.exe qmake_all
pushd gallery-core
%MINGWROOT%\bin\mingw32-make.exe && popd
pushd gallery-desktop
%MINGWROOT%\bin\mingw32-make.exe && popd
popd
copy %BUILD_DIR%\gallery-core\release\gallery-core.dll %OUT_DIR%
copy %BUILD_DIR%\gallery-desktop\release\gallery-desktop.exe %OUT_DIR%
%QTDIR%\bin\windeployqt %OUT_DIR%\gallery-desktop.exe %OUT_DIR%\gallery-core.dll
popd
```

```
Create scripts/package-linux-deb.sh with the following content:
#!/bin/bash
DIST_DIR=dist/desktop-linux
BUILD_DIR=build
ROOT_DIR=root
BIN_DIR=$ROOT_DIR/usr/bin
LIB_DIR=$ROOT_DIR/usr/lib
mkdir -p $DIST_DIR && cd $DIST_DIR
mkdir -p $BIN_DIR $LIB_DIR $BUILD_DIR
pushd $BUILD_DIR
$QTDIR/bin/qmake \
-spec linux-g++ \
"CONFIG += release" \
../../../ch13-gallery-packaging.pro
make qmake_all
pushd gallery-core && make && make install ; popd
pushd gallery-desktop && make && make install ; popd
popd
```

* Improving log messages  

```
Qt defines five log types, from the least to the most critical level:
qDebug(): This is used to write custom debug messages
qInfo(): This is used to write informational messages
qWarning(): This is used to write warnings and recoverable errors in your applications
qCrtitical(): This is used to write critical error messages and report system errors
qFatal(): This is used to write a last message before automatically existing
These are the most common placeholders you can use:
%{appname}: This is your application name
%{file}: This is the path to the source file
%{function}: This is the function name
%{line}: This is a line in the source file
%{message}: This is an original message
%{type}: This is the Qt log type ("debug", "info", "warning", "critical" or "fatal")
%{time [format]}: This is the system time when the message occurred
An easy way to use it is to edit your main.cpp file like this:
```

#include <QApplication>
#include <QDebug>
...
int main(int argc, char *argv[])
{
qSetMessagePattern("[%{time yyyy-MM-dd hh:mm:ss}] [%{type}]
%{function} %{message}"); 
qInfo() << "Application starting..."; 
QApplication a(argc, argv); 
...
return a.exec(); 
}

```
```
* Saving your logs to a file    
```

#include <QFile>
#include <QTextStream>
void messageHander(QtMsgType type, 
const QMessageLogContext& context, 
const QString& message) {
QString levelText; 
switch (type) {
case QtDebugMsg:
levelText = "Debug"; 
break; 
case QtInfoMsg:
levelText = "Info"; 
break; 
case QtWarningMsg:
levelText = "Warning"; 
break; 
case QtCriticalMsg:
levelText = "Critical"; 
break; 
case QtFatalMsg:
levelText = "Fatal"; 
break; 
}
QString text = QString("[%1] %2")
.arg(levelText)
.arg(message); 
QFile file("app.log"); 
file.open(QIODevice:: WriteOnly | QIODevice:: Append); 
QTextStream textStream(&file); 
textStream << text << endl; 
}

int main(int argc, char *argv[])
{
QCoreApplication a(argc, argv); 
qInstallMessageHandler(messageHander); 
...
}

```

* Generating a command-line interface  
```
QCoreApplication app(argc, argv); 
QCoreApplication::setApplicationName("ch14-hat-tips"); 
QCoreApplication::setApplicationVersion("1.0.0"); 
QCommandLineParser parser; 
parser.setApplicationDescription("CLI helper"); 
parser.addHelpOption(); 
parser.addVersionOption(); 
parser.addOptions({
{"debug", 
"Enable the debug mode."}, 
\{\{"f", "file"\}, 
"Write the logs into <file>.", 
"logfile"\}, 
\{\{"l", "level"\}, 
"Restrict the logs to level <level>. Default is 'fatal'.", 
"level", 
"fatal"\}, 
}); 
parser.process(app); 
qDebug() << "debug mode:" << parser.isSet("debug"); 
qDebug() << "file:" << parser.value("file"); 
qDebug() << "level:" << parser.value("level"); 

```
* Sending and receiving HTTP data  
```

#include <QObject>
#include <QNetworkAccessManager>
#include <QNetworkReply>
class HttpRequest : public QObject
{
Q_OBJECT
public:
HttpRequest(QObject* parent = 0); 
void executeGet(); 
private slots:
void replyFinished(QNetworkReply* reply); 
private:
QNetworkAccessManager mAccessManager; 
}; 

```
```
HttpRequest::HttpRequest(QObject* parent) :
QObject(parent),
mAccessManager()
{
connect(&mAccessManager, &QNetworkAccessManager::finished,
this, &HttpRequest::replyFinished);
}

// Request
void HttpRequest::executeGet()
{
QNetworkRequest request(QUrl("http://httpbin.org/ip"));
mAccessManager.get(QNetworkRequest(request));
}
// Response
void HttpRequest::replyFinished(QNetworkReply* reply)
{
int statusCode = reply-
>attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt();
qDebug() << "Reponse network error" << reply->error();
qDebug() << "Reponse HTTP status code" << statusCode;
qDebug() << "Reply content:" << reply->readAll();
reply->deleteLater();
}
void HttpRequest::executePost()
{
QNetworkRequest request(QUrl("http://httpbin.org/post"));
request.setHeader(QNetworkRequest::ContentTypeHeader,
"application/x-www-form-urlencoded");
QUrlQuery urlQuery;
urlQuery.addQueryItem("book", "Mastering Qt 5");
QUrl params;
params.setQuery(urlQuery);
QNetworkReply* reply = mAccessManager.post(
request, params.toEncoded());
connect(reply, &QNetworkReply::readyRead,
[reply] () {
qDebug() << "Ready to read from reply";
});
connect(reply, &QNetworkReply::sslErrors,
[this] (QList<QSslError> errors) {
qWarning() << "SSL errors" << errors;
});
}
void HttpRequest::executeBlockingGet()
{
QNetworkAccessManager localManager;
QEventLoop eventLoop;
QObject::connect(
&localManager, &QNetworkAccessManager::finished,
&eventLoop, &QEventLoop::quit);
QNetworkRequest request(
QUrl("http://httpbin.org/user-agent"));
request.setHeader(QNetworkRequest::UserAgentHeader,
"MasteringQt5Browser 1.0");
QNetworkReply* reply = localManager.get(request);
eventLoop.exec();
qDebug() << "Blocking GET result:" << reply->readAll();
reply->deleteLater();
}
```
